/*****************************************************************************
* This file is provided under the Creative Commons Attribution 3.0 license.
*
* You are free to share, copy, distribute, transmit, or adapt this work
* PROVIDED THAT you attribute the work to the authors listed below.
* For more information, please see the following web page:
* http://creativecommons.org/licenses/by/3.0/
*
* This file is a component of the Sleipnir library for functional genomics,
* authored by:
* Curtis Huttenhower (chuttenh@princeton.edu)
* Mark Schroeder
* Maria D. Chikina
* Olga G. Troyanskaya (ogt@princeton.edu, primary contact)
*
* If you use this library, the included executable tools, or any related
* code in your work, please cite the following publication:
* Curtis Huttenhower, Mark Schroeder, Maria D. Chikina, and
* Olga G. Troyanskaya.
* "The Sleipnir library for computational functional genomics"
*****************************************************************************/
#ifndef SVM_H
#define SVM_H

#ifndef NO_SVM_PERF

#include "svmi.h"

namespace Sleipnir {

/*!
 * \brief
 * Provides an interface for learning and evaluating support vector machines using svm_perf.
 * 
 * The CSVM class provides a variety of methods for learning and evaluating SVMs based on biological
 * data types.  All SVM manipulation is done using the svm_perf library (http://svmlight.joachims.org/),
 * but the interface between Sleipnir and svm_perf has been optimized to pass appropriate data types
 * (datasets, PCLs, etc.) as efficiently as possible.  Note that SVM learning requires the entire
 * dataset to be in memory simultaneously, so subsampling large answer sets is often necessary for SVMs
 * when it would not be for Bayesian learning.  On the other hand, individual data points can be evaluated
 * easily, so memory is only a potential issue during SVM learning.
 */
class CSVM : CSVMImpl {
public:
	/*!
	 * \brief
	 * Type of kernel used by the SVM.
	 */
	enum EKernel {
		/*!
		 * \brief
		 * Linear kernel.
		 */
		EKernelLinear		= 0,
		/*!
		 * \brief
		 * Polynomial kernel.
		 */
		EKernelPolynomial	= EKernelLinear + 1,
		/*!
		 * \brief
		 * Radial basis function kernel.
		 */
		EKernelRBF			= EKernelPolynomial + 1
	};

	bool OpenAlphas( std::istream& istm );
	bool Open( std::istream& istm );
	bool Save( std::ostream& ostm ) const;
	bool Learn( const CPCL& PCL, const CGenes& GenesPositive );
	bool Learn( const CPCL& PCL, const CGenes& GenesPositive, const CGenes& GenesNegative );
	bool Evaluate( const CPCL& PCL, std::vector<float>& vecdResults ) const;

	/*!
	 * \brief
	 * Learn an SVM using the given binary example file.
	 * 
	 * \param szData
	 * File of examples from which SVM is learned.
	 * 
	 * \returns
	 * True if the SVM was learned successfully.
	 * 
	 * Learns an SVM from an example file roughly equivalent to that given to svm_learn, but in binary
	 * form.  This can greatly speed the loading of large example files.  The binary layout of the file
	 * is:
	 * \code
	 * 4-byte unsigned integer, number of features F
	 * 4-byte unsigned integer, number of examples E
	 * E times:
	 *   4-byte float, label of the example
	 *   F times 4-byte float, values of the example's features
	 *   4-byte integer, number of characters in the example's comment C
	 *   C times 1-byte character, example's user data comment
	 * \endcode
	 * 
	 * \see
	 * Evaluate
	 */
	bool Learn( const char* szData ) {
		SData	sData;

		sData.m_eType = SData::EFile;
		sData.m_uData.m_szFile = szData;

		return CSVMImpl::Learn( sData ); }

	/*!
	 * \brief
	 * Learn an SVM using pairs of values from the given PCLs.
	 * 
	 * \param PCLs
	 * PCLs from which features are read.
	 * 
	 * \param Answers
	 * Answer set indicating positive and negative examples.
	 * 
	 * \returns
	 * True if the model was learned successfully.
	 * 
	 * Learns an SVM using the given answer set.  For each gene pair marked as positive (1) or negative (0)
	 * in the given answer file, a set of features is generated by pairing the vectors of values for the two
	 * genes from the given PCLs.  For example, if the answer file indicates that genes A and B are related,
	 * A has values of [0, 1, 2] in the given PCL, and B has values [2, 4, 0], an SVM training example will
	 * be generated of the form:
	 * \code
	 * +1 1:0 2:1 3:2 4:2 5:4 6:0
	 * \endcode
	 * Multiple PCLs within the set are concatenated (e.g. if the PCL set contains two PCLs with two and one
	 * condition, respectively, A's values [0, 1] might come from the first PCL and [2] from the second;
	 * likewise for B's [2, 4] and [0]).
	 */
	bool Learn( const CPCLSet& PCLs, const CDataPair& Answers ) {
		SData	sData;

		sData.m_eType = SData::EPCLs;
		sData.m_uData.m_pPCLs = &PCLs;
		sData.m_uAnswers.m_pAnswers = &Answers;

		return CSVMImpl::Learn( sData ); }

	/*!
	 * \brief
	 * Learn an SVM using data from the given dataset.
	 * 
	 * \param pData
	 * Dataset from which features are read.
	 * 
	 * \param Answers
	 * Answer set indicating positive and negative examples.
	 * 
	 * \returns
	 * True if the model was learned successfully.
	 * 
	 * Learns an SVM using the given answer set.  For each gene pair marked as positive (1) or negative (0)
	 * in the given answer file, a set of features is generated using each non-hidden experiment in the
	 * given dataset.  For example, if the answer file indicates that genes A and B are related, and the
	 * dataset contains three experiments with values of 2, 4, and 0 for the pair AB, an SVM training
	 * example will be generated of the form:
	 * \code
	 * +1 1:2 2:4 3:0
	 * \endcode
	 */
	bool Learn( const IDataset* pData, const CDataPair& Answers ) {
		SData	sData;

		sData.m_eType = SData::EData;
		sData.m_uData.m_pData = pData;
		sData.m_uAnswers.m_pAnswers = &Answers;

		return CSVMImpl::Learn( sData ); }

	/*!
	 * \brief
	 * Evaluate an SVM using the given binary example file.
	 * 
	 * \param szFile
	 * File of examples for which SVM is evaluated.
	 * 
	 * \param DatResults
	 * CDat into which SVM predictions are placed.
	 * 
	 * \returns
	 * True if the evaluation completed successfully.
	 * 
	 * Evaluates the current SVM on an example file roughly equivalent to that given to svm_classify, but in
	 * binary form.  This can greatly speed the loading of large example files.  The binary layout of the file
	 * is:
	 * \code
	 * 4-byte unsigned integer, number of features F
	 * 4-byte unsigned integer, number of examples E
	 * E times:
	 *   4-byte float, label of the example
	 *   F times 4-byte float, values of the example's features
	 *   4-byte integer, number of characters in the example's user data, MUST be 8
	 *   4-byte integer, index of first gene in the pair corresponding to this example
	 *   4-byte integer, index of second gene in the pair corresponding to this example
	 * 4-byte unsigned integer, total number of genes
	 * \endcode
	 * Example labels are ignored during evaluation.  The output CDat is filled based on the total number of
	 * genes and the gene pair indices labeling each example.
	 * 
	 * \remarks
	 * Sorry the file format is so quirky; it was made to play nice with svm_perf.  It's at least arranged
	 * so that it can be marginally compatible with the equivalent Learn function.  Of course, feeding
	 * either method bad input will cause who-knows-what horrific consequences.
	 */
	bool Evaluate( const char* szFile, CDat& DatResults ) const {
		SData	sData;

		sData.m_eType = SData::EFile;
		sData.m_uData.m_szFile = szFile;

		return CSVMImpl::Evaluate( sData, NULL, DatResults ); }

	/*!
	 * \brief
	 * Evaluate an SVM using pairs of values from the given PCLs.
	 * 
	 * \param PCLs
	 * PCLs from which features are read.
	 * 
	 * \param DatResults
	 * CDat into which SVM predictions are placed.
	 * 
	 * \returns
	 * True if the evaluation completed successfully.
	 * 
	 * Evaluates the current SVM using the given data.  For each gene pair in the given PCLs, a set of
	 * features is generated by pairing the vectors of values for the two genes from the PCLs.  For example,
	 * for two genes A and B, if A has values of [0, 1, 2] in the given PCL, and B has values [2, 4, 0],
	 * an SVM example will be generated of the form:
	 * \code
	 * 1:0 2:1 3:2 4:2 5:4 6:0
	 * \endcode
	 * Multiple PCLs within the set are concatenated (e.g. if the PCL set contains two PCLs with two and one
	 * condition, respectively, A's values [0, 1] might come from the first PCL and [2] from the second;
	 * likewise for B's [2, 4] and [0]).
	 */
	bool Evaluate( const CPCLSet& PCLs, CDat& DatResults ) const {
		SData	sData;

		sData.m_eType = SData::EPCLs;
		sData.m_uData.m_pPCLs = &PCLs;

		return CSVMImpl::Evaluate( sData, NULL, DatResults ); }

	/*!
	 * \brief
	 * Evaluate an SVM using values from the given dataset.
	 * 
	 * \param pData
	 * Dataset from which features are read.
	 * 
	 * \param DatResults
	 * CDat into which SVM predictions are placed.
	 * 
	 * \returns
	 * True if the evaluation completed successfully.
	 * 
	 * Evaluates the current SVM using the given data.  For each gene pair, a set of features is generated
	 * using each non-hidden experiment in the given dataset.  For example, if the dataset contains three
	 * experiments with values of 2, 4, and 0 for the pair AB, an SVM example will be generated of the form:
	 * \code
	 * 1:2 2:4 3:0
	 * \endcode
	 */
	bool Evaluate( const IDataset* pData, CDat& DatResults ) const {
		SData	sData;

		sData.m_eType = SData::EData;
		sData.m_uData.m_pData = pData;

		return CSVMImpl::Evaluate( sData, NULL, DatResults ); }

	/*!
	 * \brief
	 * Evaluate an SVM using pairs of values from the given PCLs.
	 * 
	 * \param PCLs
	 * PCLs from which features are read.
	 * 
	 * \param GenesInclude
	 * Genes to be evaluated.
	 * 
	 * \param DatResults
	 * CDat into which SVM predictions are placed.
	 * 
	 * \returns
	 * True if the evaluation completed successfully.
	 * 
	 * Evaluates the given PCLs as per other Evaluate methods, but only over pairs for which both
	 * genes are in the given gene set.
	 * 
	 * \remarks
	 * The output size (number of genes) of DatResults will be the same as the input size of GenesInclude.
	 */
	bool Evaluate( const CPCLSet& PCLs, const CGenes& GenesInclude, CDat& DatResults ) const {
		SData	sData;

		sData.m_eType = SData::EPCLs;
		sData.m_uData.m_pPCLs = &PCLs;

		return CSVMImpl::Evaluate( sData, &GenesInclude, DatResults ); }

	/*!
	 * \brief
	 * Evaluate an SVM using values from the given dataset for the requested genes.
	 * 
	 * \param pData
	 * Dataset from which features are read.
	 * 
	 * \param GenesInclude
	 * Genes to be evaluated.
	 * 
	 * \param DatResults
	 * CDat into which SVM predictions are placed.
	 * 
	 * \returns
	 * True if the evaluation completed successfully.
	 * 
	 * Evaluates the given dataset as per other Evaluate methods, but only over pairs for which both
	 * genes are in the given gene set.
	 * 
	 * \remarks
	 * The output size (number of genes) of DatResults will be the same as the input size of GenesInclude.
	 */
	bool Evaluate( const IDataset* pData, const CGenes& GenesInclude, CDat& DatResults ) const {
		SData	sData;

		sData.m_eType = SData::EData;
		sData.m_uData.m_pData = pData;

		return CSVMImpl::Evaluate( sData, &GenesInclude, DatResults ); }

	/*!
	 * \brief
	 * Set the maximum number of iterations during SVM learning.
	 * 
	 * \param iIterations
	 * Maximum number of iterations during SVM learning.
	 * 
	 * \remarks
	 * Equivalent to the -# argument to svm_learn
	 */
	void SetIterations( size_t iIterations ) {

		m_sLearn.maxiter = (long)iIterations; }

	/*!
	 * \brief
	 * Set the cache size for SVM learning and evaluation.
	 * 
	 * \param iMegabytes
	 * Cache size in megabytes for SVM learning/evaluation.
	 * 
	 * \remarks
	 * Equivalent to the -m argument to svm_learn
	 */
	void SetCache( size_t iMegabytes ) {

		m_sLearn.kernel_cache_size = (long)iMegabytes; }

	/*!
	 * \brief
	 * Set the error/margin tradeoff for SVM learning.
	 * 
	 * \param dTradeoff
	 * Error/margin tradeoff parameter C for SVM learning.
	 * 
	 * \remarks
	 * Equivalent to the -c argument to svm_learn.
	 */
	void SetTradeoff( float dTradeoff ) {

		m_sLearn.svm_c = dTradeoff; }

	/*!
	 * \brief
	 * Set the gamma parameter for learning an RBF kernel.
	 * 
	 * \param dGamma
	 * Gamma parameter for RBF kernel learning.
	 * 
	 * \remarks
	 * Equivalent to the -g parameter to svm_learn.
	 */
	void SetGamma( float dGamma ) {

		m_sKernel.rbf_gamma = dGamma; }

	/*!
	 * \brief
	 * Set the degree parameter for learning a polynomial kernel.
	 * 
	 * \param iDegree
	 * Degree parameter for polynomial kernel learning.
	 * 
	 * \remarks
	 * Equivalent to the -d parameter to svm_learn.
	 */
	void SetDegree( size_t iDegree ) {

		m_sKernel.poly_degree = (long)iDegree; }

	/*!
	 * \brief
	 * Set the kernel type parameter for SVM learning.
	 * 
	 * \param eKernel
	 * Kernel type to use for SVM learning.
	 * 
	 * \remarks
	 * Equivalent to the -t parameter to svm_learn.
	 */
	void SetKernel( EKernel eKernel ) {

		m_sKernel.kernel_type = eKernel; }

	/*!
	 * \brief
	 * Set the verbosity parameter for svm_perf.
	 * 
	 * \param iVerbosity
	 * Verbosity of messages from svm_perf.
	 * 
	 * \remarks
	 * Equivalent to the -v parameter to svm_learn/svm_classify.
	 */
	void SetVerbosity( size_t iVerbosity ) {

		verbosity = (long)iVerbosity; }
};

}

#endif // NO_SVM_PERF

#endif // SVM_H
