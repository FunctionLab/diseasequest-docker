/*
  File autogenerated by gengetopt version 2.22
  generated with the following command:
  /Genomics/ogtr03/cypark/sleipnir/../sleipnir-extlib/gengetopt-2.22/src/gengetopt -iDChecker.ggo --default-optional -u -N -e 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "getopt.h"

#include "cmdline.h"

const char *gengetopt_args_info_purpose = "Similarity to answer file checker";

const char *gengetopt_args_info_usage = "Usage: DChecker [OPTIONS]... [FILES]...";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help                 Print help and exit",
  "  -V, --version              Print version and exit",
  "\nMain:",
  "  -i, --input=filename       Similarity DAT/DAB file",
  "  -w, --answers=filename     Answer DAT/DAB file",
  "\nMiscellaneous:",
  "  -d, --directory=directory  Output directory  (default=`.')",
  "  -a, --auc=FLOAT            Use alternative AUCn calculation  (default=`0')",
  "  -R, --randomize=INT        Calculate specified number of randomized scores  \n                               (default=`0')",
  "\nRanking Method:",
  "  -b, --bins=INT             Bins for quantile sorting  (default=`1000')",
  "  -f, --finite               Count finitely many bins  (default=off)",
  "  -m, --min=FLOAT            Minimum correlation to process  (default=`0')",
  "  -M, --max=FLOAT            Maximum correlation to process  (default=`1')",
  "  -e, --delta=DOUBLE         Size of correlation bins  (default=`0.01')",
  "\nLearning/Evaluation:",
  "  -g, --genes=filename       Gene inclusion file",
  "  -G, --genex=filename       Gene exclusion file",
  "  -P, --ubiqg=filename       Ubiquitous gene file (-j and -J refer to \n                               connections to ubiq instead of all bridging \n                               pairs)",
  "  -c, --genet=filename       Term inclusion file",
  "  -C, --genee=filename       Edge inclusion file",
  "  -l, --genep=filename       Gene inclusion file for positives",
  "  -q, --ctxtpos              Use positive edges between context genes  \n                               (default=on)",
  "  -Q, --ctxtneg              Use negative edges between context genes  \n                               (default=on)",
  "  -j, --bridgepos            Use bridging positives between context and \n                               non-context genes  (default=off)",
  "  -J, --bridgeneg            Use bridging negatives between context and \n                               non-context genes  (default=on)",
  "  -u, --outpos               Use positive edges outside the context  \n                               (default=off)",
  "  -U, --outneg               Use negative edges outside the context  \n                               (default=off)",
  "  -W, --weights=filename     Weight file",
  "  -F, --flipneg              Flip weights(one minus original) for negative \n                               standards  (default=on)",
  "  -S, --singlegene           Randomly subsample the standards so that a gene \n                               occurs at most once in positive and also in \n                               negative standards  (default=off)",
  "  -E, --genec=filename       Gene file to split positives into new positive \n                               examples and negative examples. All positive \n                               pairs with both genes in the gene list are only \n                               consided as positives. All positive pairs with \n                               both genes not in the gene list are considered \n                               as negatives. (all original negatives are \n                               ignored).",
  "\nPreprocessing:",
  "  -n, --normalize            Normalize scores before processing  (default=off)",
  "  -t, --invert               Invert correlations to distances  (default=off)",
  "  -A, --abs=FLOAT            Convert input to its absolute values  \n                               (default=`0.0')",
  "\nOptional:",
  "  -s, --sse                  Calculate sum of squared errors  (default=off)",
  "  -p, --memmap               Memory map input DABs  (default=off)",
  "  -v, --verbosity=INT        Message verbosity  (default=`5')",
  "  -r, --random=INT           Seed random generator (default -1 uses current \n                               time)  (default=`-1')",
    0
};

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_INT
  , ARG_FLOAT
  , ARG_DOUBLE
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);

static int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->input_given = 0 ;
  args_info->answers_given = 0 ;
  args_info->directory_given = 0 ;
  args_info->auc_given = 0 ;
  args_info->randomize_given = 0 ;
  args_info->bins_given = 0 ;
  args_info->finite_given = 0 ;
  args_info->min_given = 0 ;
  args_info->max_given = 0 ;
  args_info->delta_given = 0 ;
  args_info->genes_given = 0 ;
  args_info->genex_given = 0 ;
  args_info->ubiqg_given = 0 ;
  args_info->genet_given = 0 ;
  args_info->genee_given = 0 ;
  args_info->genep_given = 0 ;
  args_info->ctxtpos_given = 0 ;
  args_info->ctxtneg_given = 0 ;
  args_info->bridgepos_given = 0 ;
  args_info->bridgeneg_given = 0 ;
  args_info->outpos_given = 0 ;
  args_info->outneg_given = 0 ;
  args_info->weights_given = 0 ;
  args_info->flipneg_given = 0 ;
  args_info->singlegene_given = 0 ;
  args_info->genec_given = 0 ;
  args_info->normalize_given = 0 ;
  args_info->invert_given = 0 ;
  args_info->abs_given = 0 ;
  args_info->sse_given = 0 ;
  args_info->memmap_given = 0 ;
  args_info->verbosity_given = 0 ;
  args_info->random_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  args_info->input_arg = NULL;
  args_info->input_orig = NULL;
  args_info->answers_arg = NULL;
  args_info->answers_orig = NULL;
  args_info->directory_arg = gengetopt_strdup (".");
  args_info->directory_orig = NULL;
  args_info->auc_arg = 0;
  args_info->auc_orig = NULL;
  args_info->randomize_arg = 0;
  args_info->randomize_orig = NULL;
  args_info->bins_arg = 1000;
  args_info->bins_orig = NULL;
  args_info->finite_flag = 0;
  args_info->min_arg = 0;
  args_info->min_orig = NULL;
  args_info->max_arg = 1;
  args_info->max_orig = NULL;
  args_info->delta_arg = 0.01;
  args_info->delta_orig = NULL;
  args_info->genes_arg = NULL;
  args_info->genes_orig = NULL;
  args_info->genex_arg = NULL;
  args_info->genex_orig = NULL;
  args_info->ubiqg_arg = NULL;
  args_info->ubiqg_orig = NULL;
  args_info->genet_arg = NULL;
  args_info->genet_orig = NULL;
  args_info->genee_arg = NULL;
  args_info->genee_orig = NULL;
  args_info->genep_arg = NULL;
  args_info->genep_orig = NULL;
  args_info->ctxtpos_flag = 1;
  args_info->ctxtneg_flag = 1;
  args_info->bridgepos_flag = 0;
  args_info->bridgeneg_flag = 1;
  args_info->outpos_flag = 0;
  args_info->outneg_flag = 0;
  args_info->weights_arg = NULL;
  args_info->weights_orig = NULL;
  args_info->flipneg_flag = 1;
  args_info->singlegene_flag = 0;
  args_info->genec_arg = NULL;
  args_info->genec_orig = NULL;
  args_info->normalize_flag = 0;
  args_info->invert_flag = 0;
  args_info->abs_arg = 0.0;
  args_info->abs_orig = NULL;
  args_info->sse_flag = 0;
  args_info->memmap_flag = 0;
  args_info->verbosity_arg = 5;
  args_info->verbosity_orig = NULL;
  args_info->random_arg = -1;
  args_info->random_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{


  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->input_help = gengetopt_args_info_help[3] ;
  args_info->answers_help = gengetopt_args_info_help[4] ;
  args_info->directory_help = gengetopt_args_info_help[6] ;
  args_info->auc_help = gengetopt_args_info_help[7] ;
  args_info->randomize_help = gengetopt_args_info_help[8] ;
  args_info->bins_help = gengetopt_args_info_help[10] ;
  args_info->finite_help = gengetopt_args_info_help[11] ;
  args_info->min_help = gengetopt_args_info_help[12] ;
  args_info->max_help = gengetopt_args_info_help[13] ;
  args_info->delta_help = gengetopt_args_info_help[14] ;
  args_info->genes_help = gengetopt_args_info_help[16] ;
  args_info->genex_help = gengetopt_args_info_help[17] ;
  args_info->ubiqg_help = gengetopt_args_info_help[18] ;
  args_info->genet_help = gengetopt_args_info_help[19] ;
  args_info->genee_help = gengetopt_args_info_help[20] ;
  args_info->genep_help = gengetopt_args_info_help[21] ;
  args_info->ctxtpos_help = gengetopt_args_info_help[22] ;
  args_info->ctxtneg_help = gengetopt_args_info_help[23] ;
  args_info->bridgepos_help = gengetopt_args_info_help[24] ;
  args_info->bridgeneg_help = gengetopt_args_info_help[25] ;
  args_info->outpos_help = gengetopt_args_info_help[26] ;
  args_info->outneg_help = gengetopt_args_info_help[27] ;
  args_info->weights_help = gengetopt_args_info_help[28] ;
  args_info->flipneg_help = gengetopt_args_info_help[29] ;
  args_info->singlegene_help = gengetopt_args_info_help[30] ;
  args_info->genec_help = gengetopt_args_info_help[31] ;
  args_info->normalize_help = gengetopt_args_info_help[33] ;
  args_info->invert_help = gengetopt_args_info_help[34] ;
  args_info->abs_help = gengetopt_args_info_help[35] ;
  args_info->sse_help = gengetopt_args_info_help[37] ;
  args_info->memmap_help = gengetopt_args_info_help[38] ;
  args_info->verbosity_help = gengetopt_args_info_help[39] ;
  args_info->random_help = gengetopt_args_info_help[40] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n", CMDLINE_PARSER_PACKAGE, CMDLINE_PARSER_VERSION);
}

static void print_help_common(void) {
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = NULL;
  args_info->inputs_num = 0;
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params = 
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{
  unsigned int i;
  free_string_field (&(args_info->input_arg));
  free_string_field (&(args_info->input_orig));
  free_string_field (&(args_info->answers_arg));
  free_string_field (&(args_info->answers_orig));
  free_string_field (&(args_info->directory_arg));
  free_string_field (&(args_info->directory_orig));
  free_string_field (&(args_info->auc_orig));
  free_string_field (&(args_info->randomize_orig));
  free_string_field (&(args_info->bins_orig));
  free_string_field (&(args_info->min_orig));
  free_string_field (&(args_info->max_orig));
  free_string_field (&(args_info->delta_orig));
  free_string_field (&(args_info->genes_arg));
  free_string_field (&(args_info->genes_orig));
  free_string_field (&(args_info->genex_arg));
  free_string_field (&(args_info->genex_orig));
  free_string_field (&(args_info->ubiqg_arg));
  free_string_field (&(args_info->ubiqg_orig));
  free_string_field (&(args_info->genet_arg));
  free_string_field (&(args_info->genet_orig));
  free_string_field (&(args_info->genee_arg));
  free_string_field (&(args_info->genee_orig));
  free_string_field (&(args_info->genep_arg));
  free_string_field (&(args_info->genep_orig));
  free_string_field (&(args_info->weights_arg));
  free_string_field (&(args_info->weights_orig));
  free_string_field (&(args_info->genec_arg));
  free_string_field (&(args_info->genec_orig));
  free_string_field (&(args_info->abs_orig));
  free_string_field (&(args_info->verbosity_orig));
  free_string_field (&(args_info->random_orig));
  
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);

  if (args_info->inputs_num)
    free (args_info->inputs);

  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, char *values[])
{
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->input_given)
    write_into_file(outfile, "input", args_info->input_orig, 0);
  if (args_info->answers_given)
    write_into_file(outfile, "answers", args_info->answers_orig, 0);
  if (args_info->directory_given)
    write_into_file(outfile, "directory", args_info->directory_orig, 0);
  if (args_info->auc_given)
    write_into_file(outfile, "auc", args_info->auc_orig, 0);
  if (args_info->randomize_given)
    write_into_file(outfile, "randomize", args_info->randomize_orig, 0);
  if (args_info->bins_given)
    write_into_file(outfile, "bins", args_info->bins_orig, 0);
  if (args_info->finite_given)
    write_into_file(outfile, "finite", 0, 0 );
  if (args_info->min_given)
    write_into_file(outfile, "min", args_info->min_orig, 0);
  if (args_info->max_given)
    write_into_file(outfile, "max", args_info->max_orig, 0);
  if (args_info->delta_given)
    write_into_file(outfile, "delta", args_info->delta_orig, 0);
  if (args_info->genes_given)
    write_into_file(outfile, "genes", args_info->genes_orig, 0);
  if (args_info->genex_given)
    write_into_file(outfile, "genex", args_info->genex_orig, 0);
  if (args_info->ubiqg_given)
    write_into_file(outfile, "ubiqg", args_info->ubiqg_orig, 0);
  if (args_info->genet_given)
    write_into_file(outfile, "genet", args_info->genet_orig, 0);
  if (args_info->genee_given)
    write_into_file(outfile, "genee", args_info->genee_orig, 0);
  if (args_info->genep_given)
    write_into_file(outfile, "genep", args_info->genep_orig, 0);
  if (args_info->ctxtpos_given)
    write_into_file(outfile, "ctxtpos", 0, 0 );
  if (args_info->ctxtneg_given)
    write_into_file(outfile, "ctxtneg", 0, 0 );
  if (args_info->bridgepos_given)
    write_into_file(outfile, "bridgepos", 0, 0 );
  if (args_info->bridgeneg_given)
    write_into_file(outfile, "bridgeneg", 0, 0 );
  if (args_info->outpos_given)
    write_into_file(outfile, "outpos", 0, 0 );
  if (args_info->outneg_given)
    write_into_file(outfile, "outneg", 0, 0 );
  if (args_info->weights_given)
    write_into_file(outfile, "weights", args_info->weights_orig, 0);
  if (args_info->flipneg_given)
    write_into_file(outfile, "flipneg", 0, 0 );
  if (args_info->singlegene_given)
    write_into_file(outfile, "singlegene", 0, 0 );
  if (args_info->genec_given)
    write_into_file(outfile, "genec", args_info->genec_orig, 0);
  if (args_info->normalize_given)
    write_into_file(outfile, "normalize", 0, 0 );
  if (args_info->invert_given)
    write_into_file(outfile, "invert", 0, 0 );
  if (args_info->abs_given)
    write_into_file(outfile, "abs", args_info->abs_orig, 0);
  if (args_info->sse_given)
    write_into_file(outfile, "sse", 0, 0 );
  if (args_info->memmap_given)
    write_into_file(outfile, "memmap", 0, 0 );
  if (args_info->verbosity_given)
    write_into_file(outfile, "verbosity", args_info->verbosity_orig, 0);
  if (args_info->random_given)
    write_into_file(outfile, "random", args_info->random_orig, 0);
  

  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = NULL;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char * const *argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char * const *argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, NULL);

  return result;
}

int
cmdline_parser2 (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, NULL);

  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (cmdline_parser_required2(args_info, prog_name, NULL) > 0)
    result = EXIT_FAILURE;

  return result;
}

int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error = 0;

  /* checks for required options */
  if (! args_info->input_given)
    {
      fprintf (stderr, "%s: '--input' ('-i') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  if (! args_info->answers_given)
    {
      fprintf (stderr, "%s: '--answers' ('-w') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  
  /* checks for dependences among options */

  return error;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, char *possible_values[], const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_FLOAT:
    if (val) *((float *)field) = (float)strtod (val, &stop_char);
    break;
  case ARG_DOUBLE:
    if (val) *((double *)field) = strtod (val, &stop_char);
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_FLOAT:
  case ARG_DOUBLE:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "input",	1, NULL, 'i' },
        { "answers",	1, NULL, 'w' },
        { "directory",	1, NULL, 'd' },
        { "auc",	1, NULL, 'a' },
        { "randomize",	1, NULL, 'R' },
        { "bins",	1, NULL, 'b' },
        { "finite",	0, NULL, 'f' },
        { "min",	1, NULL, 'm' },
        { "max",	1, NULL, 'M' },
        { "delta",	1, NULL, 'e' },
        { "genes",	1, NULL, 'g' },
        { "genex",	1, NULL, 'G' },
        { "ubiqg",	1, NULL, 'P' },
        { "genet",	1, NULL, 'c' },
        { "genee",	1, NULL, 'C' },
        { "genep",	1, NULL, 'l' },
        { "ctxtpos",	0, NULL, 'q' },
        { "ctxtneg",	0, NULL, 'Q' },
        { "bridgepos",	0, NULL, 'j' },
        { "bridgeneg",	0, NULL, 'J' },
        { "outpos",	0, NULL, 'u' },
        { "outneg",	0, NULL, 'U' },
        { "weights",	1, NULL, 'W' },
        { "flipneg",	0, NULL, 'F' },
        { "singlegene",	0, NULL, 'S' },
        { "genec",	1, NULL, 'E' },
        { "normalize",	0, NULL, 'n' },
        { "invert",	0, NULL, 't' },
        { "abs",	1, NULL, 'A' },
        { "sse",	0, NULL, 's' },
        { "memmap",	0, NULL, 'p' },
        { "verbosity",	1, NULL, 'v' },
        { "random",	1, NULL, 'r' },
        { NULL,	0, NULL, 0 }
      };

      c = getopt_long (argc, argv, "hVi:w:d:a:R:b:fm:M:e:g:G:P:c:C:l:qQjJuUW:FSE:ntA:spv:r:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->version_given),
              &(local_args_info.version_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "version", 'V',
              additional_error))
            goto failure;
          cmdline_parser_free (&local_args_info);
          return 0;
        
          break;
        case 'i':	/* Similarity DAT/DAB file.  */
        
        
          if (update_arg( (void *)&(args_info->input_arg), 
               &(args_info->input_orig), &(args_info->input_given),
              &(local_args_info.input_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "input", 'i',
              additional_error))
            goto failure;
        
          break;
        case 'w':	/* Answer DAT/DAB file.  */
        
        
          if (update_arg( (void *)&(args_info->answers_arg), 
               &(args_info->answers_orig), &(args_info->answers_given),
              &(local_args_info.answers_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "answers", 'w',
              additional_error))
            goto failure;
        
          break;
        case 'd':	/* Output directory.  */
        
        
          if (update_arg( (void *)&(args_info->directory_arg), 
               &(args_info->directory_orig), &(args_info->directory_given),
              &(local_args_info.directory_given), optarg, 0, ".", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "directory", 'd',
              additional_error))
            goto failure;
        
          break;
        case 'a':	/* Use alternative AUCn calculation.  */
        
        
          if (update_arg( (void *)&(args_info->auc_arg), 
               &(args_info->auc_orig), &(args_info->auc_given),
              &(local_args_info.auc_given), optarg, 0, "0", ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "auc", 'a',
              additional_error))
            goto failure;
        
          break;
        case 'R':	/* Calculate specified number of randomized scores.  */
        
        
          if (update_arg( (void *)&(args_info->randomize_arg), 
               &(args_info->randomize_orig), &(args_info->randomize_given),
              &(local_args_info.randomize_given), optarg, 0, "0", ARG_INT,
              check_ambiguity, override, 0, 0,
              "randomize", 'R',
              additional_error))
            goto failure;
        
          break;
        case 'b':	/* Bins for quantile sorting.  */
        
        
          if (update_arg( (void *)&(args_info->bins_arg), 
               &(args_info->bins_orig), &(args_info->bins_given),
              &(local_args_info.bins_given), optarg, 0, "1000", ARG_INT,
              check_ambiguity, override, 0, 0,
              "bins", 'b',
              additional_error))
            goto failure;
        
          break;
        case 'f':	/* Count finitely many bins.  */
        
        
          if (update_arg((void *)&(args_info->finite_flag), 0, &(args_info->finite_given),
              &(local_args_info.finite_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "finite", 'f',
              additional_error))
            goto failure;
        
          break;
        case 'm':	/* Minimum correlation to process.  */
        
        
          if (update_arg( (void *)&(args_info->min_arg), 
               &(args_info->min_orig), &(args_info->min_given),
              &(local_args_info.min_given), optarg, 0, "0", ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "min", 'm',
              additional_error))
            goto failure;
        
          break;
        case 'M':	/* Maximum correlation to process.  */
        
        
          if (update_arg( (void *)&(args_info->max_arg), 
               &(args_info->max_orig), &(args_info->max_given),
              &(local_args_info.max_given), optarg, 0, "1", ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "max", 'M',
              additional_error))
            goto failure;
        
          break;
        case 'e':	/* Size of correlation bins.  */
        
        
          if (update_arg( (void *)&(args_info->delta_arg), 
               &(args_info->delta_orig), &(args_info->delta_given),
              &(local_args_info.delta_given), optarg, 0, "0.01", ARG_DOUBLE,
              check_ambiguity, override, 0, 0,
              "delta", 'e',
              additional_error))
            goto failure;
        
          break;
        case 'g':	/* Gene inclusion file.  */
        
        
          if (update_arg( (void *)&(args_info->genes_arg), 
               &(args_info->genes_orig), &(args_info->genes_given),
              &(local_args_info.genes_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "genes", 'g',
              additional_error))
            goto failure;
        
          break;
        case 'G':	/* Gene exclusion file.  */
        
        
          if (update_arg( (void *)&(args_info->genex_arg), 
               &(args_info->genex_orig), &(args_info->genex_given),
              &(local_args_info.genex_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "genex", 'G',
              additional_error))
            goto failure;
        
          break;
        case 'P':	/* Ubiquitous gene file (-j and -J refer to connections to ubiq instead of all bridging pairs).  */
        
        
          if (update_arg( (void *)&(args_info->ubiqg_arg), 
               &(args_info->ubiqg_orig), &(args_info->ubiqg_given),
              &(local_args_info.ubiqg_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "ubiqg", 'P',
              additional_error))
            goto failure;
        
          break;
        case 'c':	/* Term inclusion file.  */
        
        
          if (update_arg( (void *)&(args_info->genet_arg), 
               &(args_info->genet_orig), &(args_info->genet_given),
              &(local_args_info.genet_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "genet", 'c',
              additional_error))
            goto failure;
        
          break;
        case 'C':	/* Edge inclusion file.  */
        
        
          if (update_arg( (void *)&(args_info->genee_arg), 
               &(args_info->genee_orig), &(args_info->genee_given),
              &(local_args_info.genee_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "genee", 'C',
              additional_error))
            goto failure;
        
          break;
        case 'l':	/* Gene inclusion file for positives.  */
        
        
          if (update_arg( (void *)&(args_info->genep_arg), 
               &(args_info->genep_orig), &(args_info->genep_given),
              &(local_args_info.genep_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "genep", 'l',
              additional_error))
            goto failure;
        
          break;
        case 'q':	/* Use positive edges between context genes.  */
        
        
          if (update_arg((void *)&(args_info->ctxtpos_flag), 0, &(args_info->ctxtpos_given),
              &(local_args_info.ctxtpos_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "ctxtpos", 'q',
              additional_error))
            goto failure;
        
          break;
        case 'Q':	/* Use negative edges between context genes.  */
        
        
          if (update_arg((void *)&(args_info->ctxtneg_flag), 0, &(args_info->ctxtneg_given),
              &(local_args_info.ctxtneg_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "ctxtneg", 'Q',
              additional_error))
            goto failure;
        
          break;
        case 'j':	/* Use bridging positives between context and non-context genes.  */
        
        
          if (update_arg((void *)&(args_info->bridgepos_flag), 0, &(args_info->bridgepos_given),
              &(local_args_info.bridgepos_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "bridgepos", 'j',
              additional_error))
            goto failure;
        
          break;
        case 'J':	/* Use bridging negatives between context and non-context genes.  */
        
        
          if (update_arg((void *)&(args_info->bridgeneg_flag), 0, &(args_info->bridgeneg_given),
              &(local_args_info.bridgeneg_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "bridgeneg", 'J',
              additional_error))
            goto failure;
        
          break;
        case 'u':	/* Use positive edges outside the context.  */
        
        
          if (update_arg((void *)&(args_info->outpos_flag), 0, &(args_info->outpos_given),
              &(local_args_info.outpos_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "outpos", 'u',
              additional_error))
            goto failure;
        
          break;
        case 'U':	/* Use negative edges outside the context.  */
        
        
          if (update_arg((void *)&(args_info->outneg_flag), 0, &(args_info->outneg_given),
              &(local_args_info.outneg_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "outneg", 'U',
              additional_error))
            goto failure;
        
          break;
        case 'W':	/* Weight file.  */
        
        
          if (update_arg( (void *)&(args_info->weights_arg), 
               &(args_info->weights_orig), &(args_info->weights_given),
              &(local_args_info.weights_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "weights", 'W',
              additional_error))
            goto failure;
        
          break;
        case 'F':	/* Flip weights(one minus original) for negative standards.  */
        
        
          if (update_arg((void *)&(args_info->flipneg_flag), 0, &(args_info->flipneg_given),
              &(local_args_info.flipneg_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "flipneg", 'F',
              additional_error))
            goto failure;
        
          break;
        case 'S':	/* Randomly subsample the standards so that a gene occurs at most once in positive and also in negative standards.  */
        
        
          if (update_arg((void *)&(args_info->singlegene_flag), 0, &(args_info->singlegene_given),
              &(local_args_info.singlegene_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "singlegene", 'S',
              additional_error))
            goto failure;
        
          break;
        case 'E':	/* Gene file to split positives into new positive examples and negative examples. All positive pairs with both genes in the gene list are only consided as positives. All positive pairs with both genes not in the gene list are considered as negatives. (all original negatives are ignored)..  */
        
        
          if (update_arg( (void *)&(args_info->genec_arg), 
               &(args_info->genec_orig), &(args_info->genec_given),
              &(local_args_info.genec_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "genec", 'E',
              additional_error))
            goto failure;
        
          break;
        case 'n':	/* Normalize scores before processing.  */
        
        
          if (update_arg((void *)&(args_info->normalize_flag), 0, &(args_info->normalize_given),
              &(local_args_info.normalize_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "normalize", 'n',
              additional_error))
            goto failure;
        
          break;
        case 't':	/* Invert correlations to distances.  */
        
        
          if (update_arg((void *)&(args_info->invert_flag), 0, &(args_info->invert_given),
              &(local_args_info.invert_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "invert", 't',
              additional_error))
            goto failure;
        
          break;
        case 'A':	/* Convert input to its absolute values.  */
        
        
          if (update_arg( (void *)&(args_info->abs_arg), 
               &(args_info->abs_orig), &(args_info->abs_given),
              &(local_args_info.abs_given), optarg, 0, "0.0", ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "abs", 'A',
              additional_error))
            goto failure;
        
          break;
        case 's':	/* Calculate sum of squared errors.  */
        
        
          if (update_arg((void *)&(args_info->sse_flag), 0, &(args_info->sse_given),
              &(local_args_info.sse_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "sse", 's',
              additional_error))
            goto failure;
        
          break;
        case 'p':	/* Memory map input DABs.  */
        
        
          if (update_arg((void *)&(args_info->memmap_flag), 0, &(args_info->memmap_given),
              &(local_args_info.memmap_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "memmap", 'p',
              additional_error))
            goto failure;
        
          break;
        case 'v':	/* Message verbosity.  */
        
        
          if (update_arg( (void *)&(args_info->verbosity_arg), 
               &(args_info->verbosity_orig), &(args_info->verbosity_given),
              &(local_args_info.verbosity_given), optarg, 0, "5", ARG_INT,
              check_ambiguity, override, 0, 0,
              "verbosity", 'v',
              additional_error))
            goto failure;
        
          break;
        case 'r':	/* Seed random generator (default -1 uses current time).  */
        
        
          if (update_arg( (void *)&(args_info->random_arg), 
               &(args_info->random_orig), &(args_info->random_given),
              &(local_args_info.random_given), optarg, 0, "-1", ARG_INT,
              check_ambiguity, override, 0, 0,
              "random", 'r',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error += cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  cmdline_parser_release (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */

      i = optind;
      while (i < argc)
        if (argv[i++] == argv[0]) {
          found_prog_name = 1;
          break;
        }
      i = 0;

      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        if (argv[optind++] != argv[0])
          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;
    }

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
